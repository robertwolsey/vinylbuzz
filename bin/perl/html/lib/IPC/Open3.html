<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>IPC::Open3 - open a process for reading, writing, and error handling using open3()</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;IPC::Open3 - open a process for reading, writing, and error handling using open3()</span></strong></big>
</td></tr>
</table>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#See-Also">See Also</a></li>
  <li><a href="#WARNING">WARNING</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>IPC::Open3 - open a process for reading, writing, and error handling using open3()</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    $pid = open3(\*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR,
                    &#39;some cmd and args&#39;, &#39;optarg&#39;, ...);

    my($wtr, $rdr, $err);
    use Symbol &#39;gensym&#39;; $err = gensym;
    $pid = open3($wtr, $rdr, $err,
                    &#39;some cmd and args&#39;, &#39;optarg&#39;, ...);

    waitpid( $pid, 0 );
    my $child_exit_status = $? &gt;&gt; 8;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Extremely similar to open2(), open3() spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors. If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS). The CHLD_IN will have autoflush turned on.</p>

<p>If CHLD_IN begins with <code>&lt;&amp;</code>, then CHLD_IN will be closed in the parent, and the child will read from it directly. If CHLD_OUT or CHLD_ERR begins with <code>&gt;&amp;</code>, then the child will send output directly to that filehandle. In both cases, there will be a dup(2) instead of a pipe(2) made.</p>

<p>If either reader or writer is the null string, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</p>

<p>The filehandles may also be integers, in which case they are understood as file descriptors.</p>

<p>open3() returns the process ID of the child process. It doesn&#39;t return on failure: it just raises an exception matching <code>/^open3:/</code>. However, <code>exec</code> failures in the child (such as no such file or permission denied), are just reported to CHLD_ERR under Windows and OS/2, as it is not possible to trap them.</p>

<p>If the child process dies for any reason, the next write to CHLD_IN is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</p>

<p>Note if you specify <code>-</code> as the command, in an analogous fashion to <code>open(FOO, &quot;-|&quot;)</code> the child process will just be the forked Perl process rather than an external command. This feature isn&#39;t yet supported on Win32 platforms.</p>

<p>open3() does not wait for and reap the child process after it exits. Except for short programs where it&#39;s acceptable to let the operating system take care of this, you need to do this yourself. This is normally as simple as calling <code>waitpid $pid, 0</code> when you&#39;re done with the process. Failing to do this can result in an accumulation of defunct or &quot;zombie&quot; processes. See <a href="file:/c|/perl/html/pod/perlfunc.html#waitpid">&quot;waitpid&quot; in perlfunc</a> for more information.</p>

<p>If you try to read from the child&#39;s stdout writer and their stderr writer, you&#39;ll have problems with blocking, which means you&#39;ll want to use select() or the IO::Select, which means you&#39;d best use sysread() instead of readline() for normal stuff.</p>

<p>This is very dangerous, as you may block forever. It assumes it&#39;s going to talk to something like <b>bc</b>, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like <b>bc</b> will read a line at a time and output a line at a time. Programs like <b>sort</b> that read their entire input stream first, however, are quite apt to cause deadlock.</p>

<p>The big problem with this approach is that if you don&#39;t have control over source code being run in the child process, you can&#39;t control what it does with pipe buffering. Thus you can&#39;t just open a pipe to <code>cat -v</code> and continually read and write a line from it.</p>

<h1 id="See-Also">See Also</h1>

<dl>

<dt id="IPC::Open2"><a href="file:/c|/perl/html/lib/IPC/Open2.html">IPC::Open2</a></dt>
<dd>

<p>Like Open3 but without STDERR capture.</p>

</dd>
<dt id="IPC::Run"><a>IPC::Run</a></dt>
<dd>

<p>This is a CPAN module that has better error handling and more facilities than Open3.</p>

</dd>
</dl>

<h1 id="WARNING">WARNING</h1>

<p>The order of arguments differs from that of open2().</p>

<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;IPC::Open3 - open a process for reading, writing, and error handling using open3()</span></strong></big>
</td></tr>
</table>

</body>

</html>


